import json

from swarm import Swarm
import sys
import traceback
from io import StringIO


def preprocess_data(completion_string: str) -> str:
    """Extracts Python code block from a string containing markdown-style code formatting.
    
    Processes completion strings that may contain triple-backtick code blocks by
    isolating the actual Python code content between ```python and closing ``` markers.

    param completion_string :
        completion_string (str): Raw input string potentially containing a code block.
            Example: "Here's your code:\n```python\nprint('Hello')\n```"

    Returns:
        str: Cleaned Python code string without markdown formatting.
        - If code block found: Extracted code between ```python and first closing ```
        - If no code block found: Returns original string (with error message printed)

    Example:
        >>> preprocess_data("```python\\nprint(1)\\n```")
        '\\nprint(1)\\n'
        
        >>> preprocess_data("No code here")
        Error: No code block found
        'No code here'
    """
    if f"```python" in completion_string:
        # Find start index after ```python marker
        start_idx = completion_string.find(f"```python") + len(f"```python")
        # Find end index before closing ```
        end_idx = completion_string.find("```", start_idx)
        completion_string = completion_string[start_idx:end_idx]
        
    else:
        print("Error: No code block found")
    return completion_string

def executor_code(code):
    """  
    Executes the given code string within a controlled environment.  

    This function captures the standard output and standard error generated  
    by the execution of the code. It provides feedback on the success or failure  
    of the execution, along with any relevant output or error messages.  

    Parameters:  
    code (str): A string containing the code to be executed.  

    Returns:  
    str: A feedback message indicating the result of the code execution,  
         which includes success messages, standard output, and error messages  
         if applicable.  

    Behavior:  
    - Backs up the original standard output and standard error streams.  
    - Redirects the output streams to capture any print statements and errors  
      generated by the executed code.  
    - Attempts to execute the code using `exec`.  
    - If the execution is successful, it collects any output from standard output  
      and standard error, constructs a feedback message, and returns it.  
    - If an exception occurs during execution, it captures the error output and  
      the traceback, providing detailed feedback on what went wrong.  
    - Restores the original standard output and standard error streams before  
      returning feedback.  
    """  
    print(code)
    original_stdout = sys.stdout
    original_stderr = sys.stderr
    
    sys.stdout = captured_stdout = StringIO()
    sys.stderr = captured_stderr = StringIO()
    
    feedback = ""
    
    try:
        exec(code, {})
        stdout_output = captured_stdout.getvalue().strip()
        stderr_output = captured_stderr.getvalue().strip()
        
        feedback = "Success: Code executed successfully."
        output_msgs = []
        
        if stdout_output:
            output_msgs.append(f"Output:\n{stdout_output}")
        if stderr_output:
            output_msgs.append(f"Warnings/Errors:\n{stderr_output}")
        
        if output_msgs:
            feedback += "\n\n" + "\n\n".join(output_msgs)
    
    except Exception:
        stderr_output = captured_stderr.getvalue().strip()
        traceback_output = traceback.format_exc().strip()
        
        feedback = "Error occurred:\n"
        if stderr_output:
            feedback += f"Error Output:\n{stderr_output}\n\n"
        feedback += f"Traceback:\n{traceback_output}"
    
    finally:
        sys.stdout = original_stdout
        sys.stderr = original_stderr
    
    return feedback.strip()



def process_and_print_streaming_response(response):
    content = ""
    last_sender = ""

    for chunk in response:
        if "sender" in chunk:
            last_sender = chunk["sender"]

        if "content" in chunk and chunk["content"] is not None:
            if not content and last_sender:
                print(f"\033[94m{last_sender}:\033[0m", end=" ", flush=True)
                last_sender = ""
            print(chunk["content"], end="", flush=True)
            content += chunk["content"]

        if "tool_calls" in chunk and chunk["tool_calls"] is not None:
            for tool_call in chunk["tool_calls"]:
                f = tool_call["function"]
                name = f["name"]
                if not name:
                    continue
                print(f"\033[94m{last_sender}: \033[95m{name}\033[0m()")

        if "delim" in chunk and chunk["delim"] == "end" and content:
            print()  # End of response message
            content = ""

        if "response" in chunk:
            return chunk["response"]


def pretty_print_messages(messages) -> None:
    for message in messages:
        if message["role"] != "assistant":
            continue

        # print agent name in blue
        print(f"\033[94m{message['sender']}\033[0m:", end=" ")

        # print response, if any
        if message["content"]:
            print(message["content"])

        # print tool calls in purple, if any
        tool_calls = message.get("tool_calls") or []
        if len(tool_calls) > 1:
            print()
        for tool_call in tool_calls:
            f = tool_call["function"]
            name, args = f["name"], f["arguments"]
            arg_str = json.dumps(json.loads(args)).replace(":", "=")
            print(f"\033[95m{name}\033[0m({arg_str[1:-1]})")


def run_demo_loop(
    openai_client,
    starting_agent, 
    context_variables=None, 
    stream=True, 
    debug=False) -> None:
    
    client = Swarm(openai_client)
    print("Starting Swarm CLI ğŸ")
    print('Type "exit" or "quit" to leave the chat.')

    messages = []
    agent = starting_agent

    while True:
        user_input = input("\033[90mUser\033[0m: ").strip() 
        # print("\nUser:", user_input)
        if user_input.lower() in {"exit", "quit"}:
            print("Exiting chat. Goodbye!")
            break  

        messages.append({"role": "user", "content": user_input})  #
        response = client.run(
            agent=agent,
            messages=messages,
            context_variables=context_variables or {},
            stream=stream,
            debug=debug,
        )

        if stream:
            response = process_and_print_streaming_response(response)
        else:
            pretty_print_messages(response.messages)
        messages.extend(response.messages)
        # print(response.messages)
        agent = response.agent