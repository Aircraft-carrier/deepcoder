import gradio as gr
from openai import OpenAI
from swarm import Swarm, Agent

# 配置API - 请替换为你的实际API密钥
API_KEY = "sk-1fac7836ded54cfabf056520607a4c4d"
BASE_URL = "https://api.deepseek.com"
AGENT_CODER_PROMPT = """
**Role**: You are a software programmer.

**Task**: As a programmer, you are required to complete the function. Use a Chain-of-Thought approach to break down the problem, create pseudocode, and then write the code in Python language.

**Instructions**: 
1. **Understand and Clarify**: Make sure you understand the task. 
2. **Algorithm/Method Selection**: Decide on the most efficient way. 
3. **Pseudocode Creation**: Write down the steps you will follow in pseudocode. 
4. **Code Generation**: Translate your pseudocode into executable Python code.


**Code Formatting**: Please write code in 
```python
[Code]
``` 
format.

# For example:

## Prompt 1:
```python
from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than
    given threshold.
    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)
    False
    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
    True
    \"\"\"

```

## Completion 1:
```python
    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                distance = abs(elem - elem2)
                if distance < threshold:
                    return True

    return False

```

## Prompt 2:
```python
from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to
    separate those group into separate strings and return the list of those.
    Separate groups are balanced (each open brace is properly closed) and not nested within each other
    Ignore any spaces in the input string.
    >>> separate_paren_groups('( ) (( )) (( )( ))')
    ['()', '(())', '(()())']
    \"\"\"

```

## Completion 2:
```python
    result = []
    current_string = []
    current_depth = 0

    for c in paren_string:
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
```

"""
AGENT_TESTER_PROMPT = """
**Role**: As a tester, your task is to create comprehensive test cases for the incomplete function. 

**Instructions**: 
1. Implement a comprehensive set of test cases following the guidelines above. 
2. Ensure each test case is well-documented with comments explaining the scenario it covers. 
3. Pay special attention to edge cases as they often reveal hidden bugs. 
4. For large-scale tests, focus on the function's efficiency and performance under heavy loads.


- The format of test cases should be:
```python
assert function_name(input) == expected_output, "Test Case Description"
```

# For example:

## Prompt 1:
```python
from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than
    given threshold.
    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)
    False
    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
    True
    \"\"\"

```

## Completion 1:
```python

assert has_close_elements([1.0, 2.0, 3.0], 0.5) == False
assert has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)== True

```

## Prompt 2:
```python
from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to
    separate those group into separate strings and return the list of those.
    Separate groups are balanced (each open brace is properly closed) and not nested within each other
    Ignore any spaces in the input string.
    >>> separate_paren_groups('( ) (( )) (( )( ))')
    ['()', '(())', '(()())']
    \"\"\"

```

## Completion 2:
```python

assert separate_paren_groups('( ) (( )) (( )( ))') == ['()', '(())', '(()())']

```
"""
AGENT_RUNNER_PROMPT= """
**Role**: As a runner, your task is Organize the code obtained from both the coder agent and tester agent and to execute the code   

1. **Conversion Logic**: Convert the obtained input into the form of a note.
  - Use `<code>` to encapsulate sections of code generated by the coder agent.  
  - Use `<test>` to encapsulate sections that contain test inputs.  
2. **Execute Code**: Use the `executor_code` function to test the provided test cases.  
3. **Processing Results**
  - If the test cases pass, return the generated code.  
  - If the test cases do not pass, use the `transfer_to_agent_coder` function to send feedback back to the coder_agent for further processing.  

Note:  
- When executing the `executor_code` function, the last received question-and-answer content should be transformed into the following format. This format will be used as the input for the `executor_code` function's parameter `code`, which should be a string representation of executable code.  

### programmed code  
[code]  

### test cases  
[test cases]  

- Example:  
```python  
### programmed code  
from typing import List  

def quicksort(arr: List[int]) -> List[int]:  
    ...  
    return  

### test cases  
# Test case 1: Basic test  
assert quicksort([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10], "Test case 1 failed"  
...
assert quicksort(large_array) == sorted(large_array), "Test case 7 failed"  
print("All test cases passed!")  
```
"""

# 初始化客户端
client = Swarm(OpenAI(api_key=API_KEY, base_url=BASE_URL))
coder_agent = Agent(
    name="Code Generator agent",
    model="deepseek-chat",
    instructions=AGENT_CODER_PROMPT,
    functions=[]
)

tester_agent = Agent(
    name="Tester agent",
    model="deepseek-chat",
    instructions=AGENT_TESTER_PROMPT,
    functions=[]
)



# 定义状态保存上下文变量和中间结果
class AgentState:
    def __init__(self):
        self.context = {}
        self.current_input = ""
        self.coder_output = ""
        self.tester_output = ""
        self.runner_output = ""

# 流式响应处理（保持原有）
def process_stream_response(response_stream):
    full_content = ""
    for chunk in response_stream:
        if "content" in chunk and chunk["content"]:
            full_content += chunk["content"]
            yield full_content

# 多阶段处理函数
def handle_coder_agent(history, state: AgentState):
    """处理代码生成阶段"""
    try:
        response_stream = client.run(
            agent=coder_agent,
            messages=[{"role": "user", "content": state.current_input}],
            context_variables=state.context,
            stream=True
        )
        
        full_response = ""
        for partial_content in process_stream_response(response_stream):
            full_response = partial_content
            # 实时更新代码生成结果
            updated_history = history + [
                {"role": "assistant", "content": f"**代码生成中**：\n{full_response}"}
            ]
            yield updated_history, state
        
        # 保存最终结果到状态
        state.coder_output = full_response
        return updated_history, state
        
    except Exception as e:
        error_msg = f"代码生成错误：{str(e)}"
        return history + [
            {"role": "assistant", "content": error_msg}
        ], state

def handle_tester_agent(history, state: AgentState):
    """处理测试生成阶段"""
    try:
        response_stream = client.run(
            agent=tester_agent,
            messages=[{"role": "user", "content": state.current_input}],
            context_variables=state.context,
            stream=True
        )
        
        full_response = ""
        for partial_content in process_stream_response(response_stream):
            full_response = partial_content
            # 更新测试生成结果
            updated_history = history[:-1] + [
                history[-1],
                {"role": "assistant", "content": f"**测试生成中**：\n{full_response}"}
            ]
            yield updated_history, state
        
        state.tester_output = full_response
        return updated_history, state
        
    except Exception as e:
        error_msg = f"测试生成错误：{str(e)}"
        return history + [
            {"role": "assistant", "content": error_msg}
        ], state


# 创建Gradio界面
with gr.Blocks(theme=gr.themes.Soft(), title="DeepSeek Multi-Agent") as demo:
    gr.Markdown("## DeepSeek大模型代码生成助手")
    
    # 聊天窗口（使用新版messages格式）
    chatbot = gr.Chatbot(
        value=[],
        bubble_full_width=False,
        render_markdown=True,
        height=600,
        avatar_images=(None, None),
        show_copy_button=True,
        layout="panel",
        type="messages"  # 明确指定使用新格式
    )
    
    # 状态存储
    state = gr.State(AgentState())
    
    # 输入组件
    with gr.Row():
        msg = gr.Textbox(
            scale=4,
            placeholder="输入消息...",
            container=False,
            autofocus=True
        )
        submit_btn = gr.Button("发送", variant="primary")
        clear_btn = gr.ClearButton([msg, chatbot])

    def process_message(message, history, state: AgentState):
        """处理消息并清空输入框"""
        state.current_input = message
        return "", history + [{"role": "user", "content": message}],state

    # 调整事件处理链
    msg.submit(
        process_message,
        inputs=[msg, chatbot, state],  
        outputs=[msg, chatbot, state],      
        queue=False
    ).then(
        handle_coder_agent,
        inputs=[  
            chatbot, 
            state
        ],
        outputs=[chatbot, state]
    ).then(
        handle_tester_agent,
        inputs=[  
            chatbot, 
            state
        ],
        outputs=[chatbot, state]
    )

    submit_btn.click(
        process_message,
        inputs=[msg, chatbot, state],  
        outputs=[msg, chatbot, state],      
        queue=False
    ).then(
        handle_coder_agent,
        inputs=[  
            chatbot, 
            state
        ],
        outputs=[chatbot, state]
    ).then(
        handle_tester_agent,
        inputs=[  
            chatbot, 
            state
        ],
        outputs=[chatbot, state]
    )


if __name__ == "__main__":
    demo.queue().launch()